## 组件间通信最基本方式: props
    用来实现父子之间相互通信的最基本方式, 也是用得最多的方式
    父 ==> 子, 传递的是非函数类型的属性
    子 ==> 父, 传递的是函数类型的属性
    问题: 其它关系的组件使用props就会比较麻烦

## vue自定义事件与事件总线
    原生DOM事件
        绑定原生DOM事件监听的2种情况
            1. 在html标签上绑定DOM事件名的监听
            2. 在组件标签上绑定DOM事件名的监听, 事件绑定在组件的根标签上
        当用户操作对应的界面时, 浏览器就会自动创建并封闭包含相关数据的事件对象, 分发对应的事件, 从而触发事件监听回调函数调用
        事件对象event, 本质是 "事件数据对象"
        event对象内的数据属性: target / offsetX / offsetY / keyCode等
        $event就是浏览器创建的event对象, 默认传递给事件监听回调函数的就是它
    vue自定义事件
        绑定vue自定义事件监听
            1. 只能在组件标签上绑定
            2. 事件名是任意的, 可以与原生DOM事件名相同
        只当执行$emit('自定义事件名', data)时分发自定义事件, 才会触发自定义事件监听函数调用
        $event: 就是分发自定义事件时指定的data数据
        $event可以是任意类型, 甚至可以没有
    vue的自定义事件: 
        用来实现子向父组件通信, 功能相当于函数类型的props
    全局事件总线:
        理解:
            Vue原型对象上有3个事件处理的方法: $on() / $emit() / $off()
            组件对象的原型对象是vm对象: 组件对象可以直接访问Vue原型对象上的方法
            实现任意组件间通信
        编码实现:
            将入口js中的vm作为全局事件总线对象: 
                beforeCreate() {
                    Vue.prototype.$bus = this
                }
            分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
            处理事件/接收数据的组件: this.$bus.$on('eventName', (data) => {})

## 组件间通信高级2: v-model深入理解
    原生input上的v-model的本质:  动态的value属性与原生input事件监听
        <input type="text" :value="name2" @input="name2=$event.target.value">
    组件标签上的v-model的本质:  动态的value属性与自定义input事件监听
        父组件: 
            <CustomInput :value="name4" @input="name4=$event"/>
        子组件: 
            props: ['value']
            <input type="text" :value="value" @input="$emit('input', $event.target.value)">
    利用v-model能做什么?
        v-model不仅能实现原生标签的双向数据绑定, 也能实现组件标签的双向数据绑定
        实现父子组件间数据双向同步
        一般用于封装带表单项的复用性组件
        elment-ui中: Input/CheckBox/Radio/Select等表单项组件都封装了v-model
